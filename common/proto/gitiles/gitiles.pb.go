// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/common/proto/gitiles/gitiles.proto

package gitiles

import prpc "github.com/TriggerMail/luci-go/grpc/prpc"

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	git "github.com/TriggerMail/luci-go/common/proto/git"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// LogRequest is request message for Gitiles.Log rpc.
type LogRequest struct {
	// Gitiles project, e.g. "chromium/src" part in
	// https://chromium.googlesource.com/chromium/src/+/master
	// Required.
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	// The commit where to start the listing from.
	// The value can be:
	//   - a git revision as 40-char string or its prefix so long as its unique in repo.
	//   - a ref such as "refs/heads/branch" or just "branch"
	//   - a ref defined as n-th parent of R in the form "R~n".
	//     For example, "master~2" or "deadbeef~1".
	// Required.
	Committish string `protobuf:"bytes,3,opt,name=committish,proto3" json:"committish,omitempty"`
	// If specified, only commits not reachable from this commit (inclusive)
	// will be returned.
	//
	// In git's notation, this is
	//   $ git log ^exclude_ancestors_of committish
	//  OR
	//   $ git log exclude_ancestors_of..committish
	// https://git-scm.com/docs/gitrevisions#gitrevisions-Theememtwo-dotRangeNotation
	//
	// For example, given this repo
	//
	//     base -> A -> B -> C == refs/heads/master
	//        \
	//         X -> Y -> Z  == refs/heads/release
	//
	// calling Log(committish='refs/heads/release',
	//             exclude_ancestors_of='refs/heads/master')
	// will return ['Z', Y', 'X'].
	ExcludeAncestorsOf string `protobuf:"bytes,2,opt,name=exclude_ancestors_of,json=excludeAncestorsOf,proto3" json:"exclude_ancestors_of,omitempty"`
	// If true, include tree diff in commits.
	TreeDiff bool `protobuf:"varint,4,opt,name=tree_diff,json=treeDiff,proto3" json:"tree_diff,omitempty"`
	// Value of next_page_token in LogResponse to continue.
	PageToken string `protobuf:"bytes,10,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// If > 0, number of commits to retrieve.
	PageSize             int32    `protobuf:"varint,11,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogRequest) Reset()         { *m = LogRequest{} }
func (m *LogRequest) String() string { return proto.CompactTextString(m) }
func (*LogRequest) ProtoMessage()    {}
func (*LogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cdf9f15dd6bc12a, []int{0}
}

func (m *LogRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogRequest.Unmarshal(m, b)
}
func (m *LogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogRequest.Marshal(b, m, deterministic)
}
func (m *LogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogRequest.Merge(m, src)
}
func (m *LogRequest) XXX_Size() int {
	return xxx_messageInfo_LogRequest.Size(m)
}
func (m *LogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogRequest proto.InternalMessageInfo

func (m *LogRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *LogRequest) GetCommittish() string {
	if m != nil {
		return m.Committish
	}
	return ""
}

func (m *LogRequest) GetExcludeAncestorsOf() string {
	if m != nil {
		return m.ExcludeAncestorsOf
	}
	return ""
}

func (m *LogRequest) GetTreeDiff() bool {
	if m != nil {
		return m.TreeDiff
	}
	return false
}

func (m *LogRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *LogRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// LogRequest is response message for Gitiles.Log rpc.
type LogResponse struct {
	// Retrieved commits.
	Log []*git.Commit `protobuf:"bytes,1,rep,name=log,proto3" json:"log,omitempty"`
	// A page token for next LogRequest to fetch next page of commits.
	NextPageToken        string   `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogResponse) Reset()         { *m = LogResponse{} }
func (m *LogResponse) String() string { return proto.CompactTextString(m) }
func (*LogResponse) ProtoMessage()    {}
func (*LogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cdf9f15dd6bc12a, []int{1}
}

func (m *LogResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogResponse.Unmarshal(m, b)
}
func (m *LogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogResponse.Marshal(b, m, deterministic)
}
func (m *LogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogResponse.Merge(m, src)
}
func (m *LogResponse) XXX_Size() int {
	return xxx_messageInfo_LogResponse.Size(m)
}
func (m *LogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LogResponse proto.InternalMessageInfo

func (m *LogResponse) GetLog() []*git.Commit {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// RefsRequest is a request message of Gitiles.Refs RPC.
type RefsRequest struct {
	// Gitiles project, e.g. "chromium/src" part in
	// https://chromium.googlesource.com/chromium/src/+/master
	// Required.
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	// Limits which refs to resolve to only those matching {refsPath}/*.
	//
	// Must be "refs" or start with "refs/".
	// Must not include glob '*'.
	// Use "refs/heads" to retrieve all branches.
	//
	// To fetch **all** refs in a repo, specify just "refs" but beware of two
	// caveats:
	//  * refs returned include a ref for each patchset for each Gerrit change
	//    associated with the repo.
	//  * returned map will contain special "HEAD" ref whose value in resulting map
	//    will be name of the actual ref to which "HEAD" points, which is typically
	//    "refs/heads/master".
	//
	// Thus, if you are looking for all tags and all branches of repo, it's
	// recommended to issue two Refs calls limited to "refs/tags" and "refs/heads"
	// instead of one call for "refs".
	//
	// Since Gerrit allows per-ref ACLs, it is possible that some refs matching
	// refPrefix would not be present in results because current user isn't granted
	// read permission on them.
	RefsPath             string   `protobuf:"bytes,2,opt,name=refs_path,json=refsPath,proto3" json:"refs_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RefsRequest) Reset()         { *m = RefsRequest{} }
func (m *RefsRequest) String() string { return proto.CompactTextString(m) }
func (*RefsRequest) ProtoMessage()    {}
func (*RefsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cdf9f15dd6bc12a, []int{2}
}

func (m *RefsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RefsRequest.Unmarshal(m, b)
}
func (m *RefsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RefsRequest.Marshal(b, m, deterministic)
}
func (m *RefsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefsRequest.Merge(m, src)
}
func (m *RefsRequest) XXX_Size() int {
	return xxx_messageInfo_RefsRequest.Size(m)
}
func (m *RefsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RefsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RefsRequest proto.InternalMessageInfo

func (m *RefsRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *RefsRequest) GetRefsPath() string {
	if m != nil {
		return m.RefsPath
	}
	return ""
}

// RefsResponse is a response message of Gitiles.Refs RPC.
type RefsResponse struct {
	// revisions maps a ref to a revision.
	// Git branches have keys start with "refs/heads/".
	Revisions            map[string]string `protobuf:"bytes,2,rep,name=revisions,proto3" json:"revisions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RefsResponse) Reset()         { *m = RefsResponse{} }
func (m *RefsResponse) String() string { return proto.CompactTextString(m) }
func (*RefsResponse) ProtoMessage()    {}
func (*RefsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cdf9f15dd6bc12a, []int{3}
}

func (m *RefsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RefsResponse.Unmarshal(m, b)
}
func (m *RefsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RefsResponse.Marshal(b, m, deterministic)
}
func (m *RefsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefsResponse.Merge(m, src)
}
func (m *RefsResponse) XXX_Size() int {
	return xxx_messageInfo_RefsResponse.Size(m)
}
func (m *RefsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RefsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RefsResponse proto.InternalMessageInfo

func (m *RefsResponse) GetRevisions() map[string]string {
	if m != nil {
		return m.Revisions
	}
	return nil
}

func init() {
	proto.RegisterType((*LogRequest)(nil), "gitiles.LogRequest")
	proto.RegisterType((*LogResponse)(nil), "gitiles.LogResponse")
	proto.RegisterType((*RefsRequest)(nil), "gitiles.RefsRequest")
	proto.RegisterType((*RefsResponse)(nil), "gitiles.RefsResponse")
	proto.RegisterMapType((map[string]string)(nil), "gitiles.RefsResponse.RevisionsEntry")
}

func init() {
	proto.RegisterFile("github.com/TriggerMail/luci-go/common/proto/gitiles/gitiles.proto", fileDescriptor_4cdf9f15dd6bc12a)
}

var fileDescriptor_4cdf9f15dd6bc12a = []byte{
	// 427 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xdd, 0x6a, 0xd4, 0x40,
	0x14, 0x80, 0x9b, 0x4d, 0xeb, 0xee, 0x9e, 0xf8, 0xc7, 0xb8, 0xc2, 0xb0, 0xa5, 0xb2, 0x04, 0x91,
	0xbd, 0xca, 0xca, 0x8a, 0x28, 0xe2, 0x8d, 0x5a, 0xf1, 0xa6, 0x60, 0x89, 0xbd, 0x0f, 0x31, 0x3d,
	0x99, 0x1d, 0x9b, 0xe4, 0xc4, 0x99, 0x49, 0x69, 0xfb, 0x14, 0xbe, 0x9a, 0x6f, 0x24, 0x33, 0x93,
	0xd8, 0x5d, 0x11, 0xf4, 0x2a, 0x39, 0xdf, 0xf9, 0xfb, 0x26, 0x19, 0x78, 0x25, 0x28, 0x29, 0x36,
	0x8a, 0x6a, 0xd9, 0xd5, 0x09, 0x29, 0xb1, 0xaa, 0xba, 0x42, 0xae, 0x0a, 0xaa, 0x6b, 0x6a, 0x56,
	0xad, 0x22, 0x43, 0x2b, 0x21, 0x8d, 0xac, 0x50, 0x0f, 0xcf, 0xc4, 0x51, 0x36, 0xee, 0xc3, 0xf9,
	0xfa, 0xbf, 0x26, 0x38, 0x20, 0x8d, 0x6f, 0x8e, 0x7f, 0x06, 0x00, 0x27, 0x24, 0x52, 0xfc, 0xde,
	0xa1, 0x36, 0x8c, 0xc3, 0xb8, 0x55, 0xf4, 0x0d, 0x0b, 0xc3, 0x83, 0x45, 0xb0, 0x9c, 0xa6, 0x43,
	0xc8, 0x9e, 0x00, 0xf8, 0x46, 0x23, 0xf5, 0x86, 0x87, 0x2e, 0xb9, 0x45, 0xd8, 0x73, 0x98, 0xe1,
	0x55, 0x51, 0x75, 0xe7, 0x98, 0xe5, 0x4d, 0x81, 0xda, 0x90, 0xd2, 0x19, 0x95, 0x7c, 0xe4, 0x2a,
	0x59, 0x9f, 0x7b, 0x37, 0xa4, 0x3e, 0x97, 0xec, 0x10, 0xa6, 0x46, 0x21, 0x66, 0xe7, 0xb2, 0x2c,
	0xf9, 0xfe, 0x22, 0x58, 0x4e, 0xd2, 0x89, 0x05, 0xc7, 0xb2, 0x2c, 0xd9, 0x11, 0x40, 0x9b, 0x0b,
	0xcc, 0x0c, 0x5d, 0x60, 0xc3, 0xc1, 0x0d, 0x99, 0x5a, 0x72, 0x66, 0x81, 0xed, 0x75, 0x69, 0x2d,
	0x6f, 0x90, 0x47, 0x8b, 0x60, 0x79, 0x90, 0x4e, 0x2c, 0xf8, 0x22, 0x6f, 0x30, 0x3e, 0x83, 0xc8,
	0x1d, 0x49, 0xb7, 0xd4, 0x68, 0x64, 0x47, 0x10, 0x56, 0x24, 0x78, 0xb0, 0x08, 0x97, 0xd1, 0x3a,
	0x4a, 0x84, 0x34, 0xc9, 0x07, 0xe7, 0x9d, 0x5a, 0xce, 0x9e, 0xc1, 0x83, 0x06, 0xaf, 0x4c, 0xb6,
	0xb5, 0xce, 0x3b, 0xdf, 0xb3, 0xf8, 0x74, 0x58, 0x19, 0x1f, 0x43, 0x94, 0x62, 0xa9, 0xff, 0xfd,
	0xa5, 0x0e, 0x61, 0xaa, 0xb0, 0xd4, 0x59, 0x9b, 0x9b, 0x4d, 0x3f, 0x6a, 0x62, 0xc1, 0x69, 0x6e,
	0x36, 0xf1, 0x8f, 0x00, 0xee, 0xfa, 0x31, 0xbd, 0xdd, 0x7b, 0x5b, 0x7d, 0x29, 0xb5, 0xa4, 0x46,
	0xf3, 0x91, 0x73, 0x7c, 0x9a, 0x0c, 0x3f, 0x78, 0xbb, 0x32, 0x49, 0x87, 0xb2, 0x8f, 0x8d, 0x51,
	0xd7, 0xe9, 0x6d, 0xdb, 0xfc, 0x2d, 0xdc, 0xdf, 0x4d, 0xb2, 0x87, 0x10, 0x5e, 0xe0, 0x75, 0x6f,
	0x66, 0x5f, 0xd9, 0x0c, 0x0e, 0x2e, 0xf3, 0xaa, 0xc3, 0xde, 0xc8, 0x07, 0x6f, 0x46, 0xaf, 0x83,
	0xb5, 0x81, 0xf1, 0x27, 0xbf, 0x8f, 0xad, 0x21, 0x3c, 0x21, 0xc1, 0x1e, 0xfd, 0x16, 0xb8, 0xbd,
	0x1a, 0xf3, 0xd9, 0x2e, 0xf4, 0x52, 0xf1, 0x1e, 0x7b, 0x09, 0xfb, 0x56, 0x93, 0xcd, 0xfe, 0xb0,
	0xf6, 0x5d, 0x8f, 0xff, 0x7a, 0x96, 0x78, 0xef, 0xeb, 0x1d, 0x77, 0xff, 0x5e, 0xfc, 0x0a, 0x00,
	0x00, 0xff, 0xff, 0x2b, 0xec, 0xca, 0xbf, 0xf7, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GitilesClient is the client API for Gitiles service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GitilesClient interface {
	// Log retrieves commit log.
	Log(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// Refs retrieves repo refs.
	Refs(ctx context.Context, in *RefsRequest, opts ...grpc.CallOption) (*RefsResponse, error)
}
type gitilesPRPCClient struct {
	client *prpc.Client
}

func NewGitilesPRPCClient(client *prpc.Client) GitilesClient {
	return &gitilesPRPCClient{client}
}

func (c *gitilesPRPCClient) Log(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.client.Call(ctx, "gitiles.Gitiles", "Log", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitilesPRPCClient) Refs(ctx context.Context, in *RefsRequest, opts ...grpc.CallOption) (*RefsResponse, error) {
	out := new(RefsResponse)
	err := c.client.Call(ctx, "gitiles.Gitiles", "Refs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type gitilesClient struct {
	cc *grpc.ClientConn
}

func NewGitilesClient(cc *grpc.ClientConn) GitilesClient {
	return &gitilesClient{cc}
}

func (c *gitilesClient) Log(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/gitiles.Gitiles/Log", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitilesClient) Refs(ctx context.Context, in *RefsRequest, opts ...grpc.CallOption) (*RefsResponse, error) {
	out := new(RefsResponse)
	err := c.cc.Invoke(ctx, "/gitiles.Gitiles/Refs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GitilesServer is the server API for Gitiles service.
type GitilesServer interface {
	// Log retrieves commit log.
	Log(context.Context, *LogRequest) (*LogResponse, error)
	// Refs retrieves repo refs.
	Refs(context.Context, *RefsRequest) (*RefsResponse, error)
}

func RegisterGitilesServer(s prpc.Registrar, srv GitilesServer) {
	s.RegisterService(&_Gitiles_serviceDesc, srv)
}

func _Gitiles_Log_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitilesServer).Log(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitiles.Gitiles/Log",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitilesServer).Log(ctx, req.(*LogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gitiles_Refs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitilesServer).Refs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitiles.Gitiles/Refs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitilesServer).Refs(ctx, req.(*RefsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gitiles_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gitiles.Gitiles",
	HandlerType: (*GitilesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Log",
			Handler:    _Gitiles_Log_Handler,
		},
		{
			MethodName: "Refs",
			Handler:    _Gitiles_Refs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/TriggerMail/luci-go/common/proto/gitiles/gitiles.proto",
}
