// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/TriggerMail/luci-go/tokenserver/api/admin/v1/admin.proto

package admin

import prpc "github.com/TriggerMail/luci-go/grpc/prpc"

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	messages "github.com/TriggerMail/luci-go/server/auth/delegation/messages"
	api "github.com/TriggerMail/luci-go/tokenserver/api"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ImportedConfigs is returned by Import<something>Configs methods on success.
type ImportedConfigs struct {
	// The revision of the configs that are now in the datastore.
	//
	// It's either the imported revision, if configs change, or a previously known
	// revision, if configs at HEAD are same.
	Revision             string   `protobuf:"bytes,1,opt,name=revision,proto3" json:"revision,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImportedConfigs) Reset()         { *m = ImportedConfigs{} }
func (m *ImportedConfigs) String() string { return proto.CompactTextString(m) }
func (*ImportedConfigs) ProtoMessage()    {}
func (*ImportedConfigs) Descriptor() ([]byte, []int) {
	return fileDescriptor_303c2e4773396ed5, []int{0}
}

func (m *ImportedConfigs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImportedConfigs.Unmarshal(m, b)
}
func (m *ImportedConfigs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImportedConfigs.Marshal(b, m, deterministic)
}
func (m *ImportedConfigs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportedConfigs.Merge(m, src)
}
func (m *ImportedConfigs) XXX_Size() int {
	return xxx_messageInfo_ImportedConfigs.Size(m)
}
func (m *ImportedConfigs) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportedConfigs.DiscardUnknown(m)
}

var xxx_messageInfo_ImportedConfigs proto.InternalMessageInfo

func (m *ImportedConfigs) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

// InspectMachineTokenRequest is body of InspectMachineToken RPC call.
//
// It contains machine token of some kind.
type InspectMachineTokenRequest struct {
	// The type of token being checked.
	//
	// Currently only LUCI_MACHINE_TOKEN is supported. This is also the default.
	TokenType api.MachineTokenType `protobuf:"varint,1,opt,name=token_type,json=tokenType,proto3,enum=tokenserver.MachineTokenType" json:"token_type,omitempty"`
	// The token body. Exact meaning depends on token_type.
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectMachineTokenRequest) Reset()         { *m = InspectMachineTokenRequest{} }
func (m *InspectMachineTokenRequest) String() string { return proto.CompactTextString(m) }
func (*InspectMachineTokenRequest) ProtoMessage()    {}
func (*InspectMachineTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_303c2e4773396ed5, []int{1}
}

func (m *InspectMachineTokenRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InspectMachineTokenRequest.Unmarshal(m, b)
}
func (m *InspectMachineTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InspectMachineTokenRequest.Marshal(b, m, deterministic)
}
func (m *InspectMachineTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectMachineTokenRequest.Merge(m, src)
}
func (m *InspectMachineTokenRequest) XXX_Size() int {
	return xxx_messageInfo_InspectMachineTokenRequest.Size(m)
}
func (m *InspectMachineTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectMachineTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectMachineTokenRequest proto.InternalMessageInfo

func (m *InspectMachineTokenRequest) GetTokenType() api.MachineTokenType {
	if m != nil {
		return m.TokenType
	}
	return api.MachineTokenType_UNKNOWN_TYPE
}

func (m *InspectMachineTokenRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// InspectMachineTokenResponse is return value of InspectMachineToken RPC call.
type InspectMachineTokenResponse struct {
	// True if the token is valid.
	//
	// A token is valid if its signature is correct, it hasn't expired yet and
	// the credentials it was built from (e.g. a certificate) wasn't revoked.
	Valid bool `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	// Human readable summary of why token is invalid.
	//
	// Summarizes the rest of the fields of this struct. Set only if 'valid' is
	// false.
	InvalidityReason string `protobuf:"bytes,2,opt,name=invalidity_reason,json=invalidityReason,proto3" json:"invalidity_reason,omitempty"`
	// True if the token signature was verified.
	//
	// It means the token was generated by the token server and its body is not
	// a garbage. Note that a token can be correctly signed, but invalid (if it
	// has expired or was revoked).
	//
	// If 'signed' is false, the fields below may (or may not) be a garbage.
	//
	// The token server uses private keys managed by Google Cloud Platform, they
	// are constantly being rotated and "old" signatures become invalid over time
	// (when corresponding keys are rotated out of existence).
	//
	// If 'signed' is false, use the rest of the response only as FYI, possibly
	// invalid or even maliciously constructed.
	Signed bool `protobuf:"varint,3,opt,name=signed,proto3" json:"signed,omitempty"`
	// True if the token signature was verified and token hasn't expired yet.
	//
	// We use "non_" prefix to make default 'false' value safer.
	NonExpired bool `protobuf:"varint,4,opt,name=non_expired,json=nonExpired,proto3" json:"non_expired,omitempty"`
	// True if the token signature was verified and the token wasn't revoked.
	//
	// It is possible for an expired token to be non revoked. They are independent
	// properties.
	//
	// We use "non_" prefix to make default 'false' value safer.
	NonRevoked bool `protobuf:"varint,5,opt,name=non_revoked,json=nonRevoked,proto3" json:"non_revoked,omitempty"`
	// Id of a private key used to sign this token, if applicable.
	SigningKeyId string `protobuf:"bytes,6,opt,name=signing_key_id,json=signingKeyId,proto3" json:"signing_key_id,omitempty"`
	// Name of a CA that issued the cert the token is based on, if applicable.
	//
	// Resolved from 'ca_id' field of the token body.
	CertCaName string `protobuf:"bytes,7,opt,name=cert_ca_name,json=certCaName,proto3" json:"cert_ca_name,omitempty"`
	// The decoded token body (depends on token_type request parameter). Empty if
	// token was malformed and couldn't be deserialized.
	//
	// Types that are valid to be assigned to TokenType:
	//	*InspectMachineTokenResponse_LuciMachineToken
	TokenType            isInspectMachineTokenResponse_TokenType `protobuf_oneof:"token_type"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *InspectMachineTokenResponse) Reset()         { *m = InspectMachineTokenResponse{} }
func (m *InspectMachineTokenResponse) String() string { return proto.CompactTextString(m) }
func (*InspectMachineTokenResponse) ProtoMessage()    {}
func (*InspectMachineTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_303c2e4773396ed5, []int{2}
}

func (m *InspectMachineTokenResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InspectMachineTokenResponse.Unmarshal(m, b)
}
func (m *InspectMachineTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InspectMachineTokenResponse.Marshal(b, m, deterministic)
}
func (m *InspectMachineTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectMachineTokenResponse.Merge(m, src)
}
func (m *InspectMachineTokenResponse) XXX_Size() int {
	return xxx_messageInfo_InspectMachineTokenResponse.Size(m)
}
func (m *InspectMachineTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectMachineTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InspectMachineTokenResponse proto.InternalMessageInfo

func (m *InspectMachineTokenResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *InspectMachineTokenResponse) GetInvalidityReason() string {
	if m != nil {
		return m.InvalidityReason
	}
	return ""
}

func (m *InspectMachineTokenResponse) GetSigned() bool {
	if m != nil {
		return m.Signed
	}
	return false
}

func (m *InspectMachineTokenResponse) GetNonExpired() bool {
	if m != nil {
		return m.NonExpired
	}
	return false
}

func (m *InspectMachineTokenResponse) GetNonRevoked() bool {
	if m != nil {
		return m.NonRevoked
	}
	return false
}

func (m *InspectMachineTokenResponse) GetSigningKeyId() string {
	if m != nil {
		return m.SigningKeyId
	}
	return ""
}

func (m *InspectMachineTokenResponse) GetCertCaName() string {
	if m != nil {
		return m.CertCaName
	}
	return ""
}

type isInspectMachineTokenResponse_TokenType interface {
	isInspectMachineTokenResponse_TokenType()
}

type InspectMachineTokenResponse_LuciMachineToken struct {
	LuciMachineToken *api.MachineTokenBody `protobuf:"bytes,20,opt,name=luci_machine_token,json=luciMachineToken,proto3,oneof"`
}

func (*InspectMachineTokenResponse_LuciMachineToken) isInspectMachineTokenResponse_TokenType() {}

func (m *InspectMachineTokenResponse) GetTokenType() isInspectMachineTokenResponse_TokenType {
	if m != nil {
		return m.TokenType
	}
	return nil
}

func (m *InspectMachineTokenResponse) GetLuciMachineToken() *api.MachineTokenBody {
	if x, ok := m.GetTokenType().(*InspectMachineTokenResponse_LuciMachineToken); ok {
		return x.LuciMachineToken
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InspectMachineTokenResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InspectMachineTokenResponse_OneofMarshaler, _InspectMachineTokenResponse_OneofUnmarshaler, _InspectMachineTokenResponse_OneofSizer, []interface{}{
		(*InspectMachineTokenResponse_LuciMachineToken)(nil),
	}
}

func _InspectMachineTokenResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InspectMachineTokenResponse)
	// token_type
	switch x := m.TokenType.(type) {
	case *InspectMachineTokenResponse_LuciMachineToken:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LuciMachineToken); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InspectMachineTokenResponse.TokenType has unexpected type %T", x)
	}
	return nil
}

func _InspectMachineTokenResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InspectMachineTokenResponse)
	switch tag {
	case 20: // token_type.luci_machine_token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(api.MachineTokenBody)
		err := b.DecodeMessage(msg)
		m.TokenType = &InspectMachineTokenResponse_LuciMachineToken{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InspectMachineTokenResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InspectMachineTokenResponse)
	// token_type
	switch x := m.TokenType.(type) {
	case *InspectMachineTokenResponse_LuciMachineToken:
		s := proto.Size(x.LuciMachineToken)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// InspectDelegationTokenRequest is body of InspectDelegationToken RPC call.
type InspectDelegationTokenRequest struct {
	// The token body.
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectDelegationTokenRequest) Reset()         { *m = InspectDelegationTokenRequest{} }
func (m *InspectDelegationTokenRequest) String() string { return proto.CompactTextString(m) }
func (*InspectDelegationTokenRequest) ProtoMessage()    {}
func (*InspectDelegationTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_303c2e4773396ed5, []int{3}
}

func (m *InspectDelegationTokenRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InspectDelegationTokenRequest.Unmarshal(m, b)
}
func (m *InspectDelegationTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InspectDelegationTokenRequest.Marshal(b, m, deterministic)
}
func (m *InspectDelegationTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectDelegationTokenRequest.Merge(m, src)
}
func (m *InspectDelegationTokenRequest) XXX_Size() int {
	return xxx_messageInfo_InspectDelegationTokenRequest.Size(m)
}
func (m *InspectDelegationTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectDelegationTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectDelegationTokenRequest proto.InternalMessageInfo

func (m *InspectDelegationTokenRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// InspectDelegationTokenResponse is return value of InspectDelegationToken RPC.
type InspectDelegationTokenResponse struct {
	// True if the token is valid.
	//
	// A token is valid if its signature is correct and it hasn't expired yet.
	Valid bool `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	// Human readable summary of why token is invalid.
	//
	// Summarizes the rest of the fields of this struct. Set only if 'valid' is
	// false.
	InvalidityReason string `protobuf:"bytes,2,opt,name=invalidity_reason,json=invalidityReason,proto3" json:"invalidity_reason,omitempty"`
	// True if the token signature was verified.
	//
	// It means the token was generated by the token server and its body is not
	// a garbage. Note that a token can be correctly signed, but invalid (if it
	// has expired).
	//
	// If 'signed' is false, the fields below may (or may not) be a garbage.
	//
	// The token server uses private keys managed by Google Cloud Platform, they
	// are constantly being rotated and "old" signatures become invalid over time
	// (when corresponding keys are rotated out of existence).
	//
	// If 'signed' is false, use the rest of the response only as FYI, possibly
	// invalid or even maliciously constructed.
	Signed bool `protobuf:"varint,3,opt,name=signed,proto3" json:"signed,omitempty"`
	// True if the token signature was verified and token hasn't expired yet.
	//
	// We use "non_" prefix to make default 'false' value safer.
	NonExpired bool `protobuf:"varint,4,opt,name=non_expired,json=nonExpired,proto3" json:"non_expired,omitempty"`
	// The deserialized token envelope.
	//
	// May be empty if token was malformed and couldn't be deserialized.
	Envelope *messages.DelegationToken `protobuf:"bytes,5,opt,name=envelope,proto3" json:"envelope,omitempty"`
	// The deserialized token body (deserialized 'envelope.serialized_subtoken').
	//
	// May be empty if token was malformed and couldn't be deserialized.
	Subtoken             *messages.Subtoken `protobuf:"bytes,6,opt,name=subtoken,proto3" json:"subtoken,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *InspectDelegationTokenResponse) Reset()         { *m = InspectDelegationTokenResponse{} }
func (m *InspectDelegationTokenResponse) String() string { return proto.CompactTextString(m) }
func (*InspectDelegationTokenResponse) ProtoMessage()    {}
func (*InspectDelegationTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_303c2e4773396ed5, []int{4}
}

func (m *InspectDelegationTokenResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InspectDelegationTokenResponse.Unmarshal(m, b)
}
func (m *InspectDelegationTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InspectDelegationTokenResponse.Marshal(b, m, deterministic)
}
func (m *InspectDelegationTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectDelegationTokenResponse.Merge(m, src)
}
func (m *InspectDelegationTokenResponse) XXX_Size() int {
	return xxx_messageInfo_InspectDelegationTokenResponse.Size(m)
}
func (m *InspectDelegationTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectDelegationTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InspectDelegationTokenResponse proto.InternalMessageInfo

func (m *InspectDelegationTokenResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *InspectDelegationTokenResponse) GetInvalidityReason() string {
	if m != nil {
		return m.InvalidityReason
	}
	return ""
}

func (m *InspectDelegationTokenResponse) GetSigned() bool {
	if m != nil {
		return m.Signed
	}
	return false
}

func (m *InspectDelegationTokenResponse) GetNonExpired() bool {
	if m != nil {
		return m.NonExpired
	}
	return false
}

func (m *InspectDelegationTokenResponse) GetEnvelope() *messages.DelegationToken {
	if m != nil {
		return m.Envelope
	}
	return nil
}

func (m *InspectDelegationTokenResponse) GetSubtoken() *messages.Subtoken {
	if m != nil {
		return m.Subtoken
	}
	return nil
}

// InspectOAuthTokenGrantRequest is body of InspectOAuthTokenGrant RPC call.
type InspectOAuthTokenGrantRequest struct {
	// The token body.
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectOAuthTokenGrantRequest) Reset()         { *m = InspectOAuthTokenGrantRequest{} }
func (m *InspectOAuthTokenGrantRequest) String() string { return proto.CompactTextString(m) }
func (*InspectOAuthTokenGrantRequest) ProtoMessage()    {}
func (*InspectOAuthTokenGrantRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_303c2e4773396ed5, []int{5}
}

func (m *InspectOAuthTokenGrantRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InspectOAuthTokenGrantRequest.Unmarshal(m, b)
}
func (m *InspectOAuthTokenGrantRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InspectOAuthTokenGrantRequest.Marshal(b, m, deterministic)
}
func (m *InspectOAuthTokenGrantRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectOAuthTokenGrantRequest.Merge(m, src)
}
func (m *InspectOAuthTokenGrantRequest) XXX_Size() int {
	return xxx_messageInfo_InspectOAuthTokenGrantRequest.Size(m)
}
func (m *InspectOAuthTokenGrantRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectOAuthTokenGrantRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectOAuthTokenGrantRequest proto.InternalMessageInfo

func (m *InspectOAuthTokenGrantRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// InspectOAuthTokenGrantResponse is return value of InspectOAuthTokenGrant RPC.
type InspectOAuthTokenGrantResponse struct {
	// True if the token is valid.
	//
	// A token is valid if its signature is correct, it hasn't expired yet and
	// token server rules still allow it.
	Valid bool `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	// Human readable summary of why token is invalid.
	//
	// Summarizes the rest of the fields of this struct. Set only if 'valid' is
	// false.
	InvalidityReason string `protobuf:"bytes,2,opt,name=invalidity_reason,json=invalidityReason,proto3" json:"invalidity_reason,omitempty"`
	// True if the token signature was verified.
	//
	// It means the token was generated by the token server and its body is not
	// a garbage. Note that a token can be correctly signed, but invalid (if it
	// has expired).
	//
	// If 'signed' is false, the fields below may (or may not) be a garbage.
	//
	// The token server uses private keys managed by Google Cloud Platform, they
	// are constantly being rotated and "old" signatures become invalid over time
	// (when corresponding keys are rotated out of existence).
	//
	// If 'signed' is false, use the rest of the response only as FYI, possibly
	// invalid or even maliciously constructed.
	Signed bool `protobuf:"varint,3,opt,name=signed,proto3" json:"signed,omitempty"`
	// True if the token signature was verified and token hasn't expired yet.
	//
	// We use "non_" prefix to make default 'false' value safer.
	NonExpired bool `protobuf:"varint,4,opt,name=non_expired,json=nonExpired,proto3" json:"non_expired,omitempty"`
	// ID of a token server private key used to sign the token.
	SigningKeyId string `protobuf:"bytes,5,opt,name=signing_key_id,json=signingKeyId,proto3" json:"signing_key_id,omitempty"`
	// The deserialized token body.
	//
	// May be empty if token was malformed and couldn't be deserialized.
	TokenBody *api.OAuthTokenGrantBody `protobuf:"bytes,6,opt,name=token_body,json=tokenBody,proto3" json:"token_body,omitempty"`
	// The service_accounts.cfg rule that governs the service account usage.
	//
	// May be present even if the token is not allowed by it.
	MatchingRule *ServiceAccountRule `protobuf:"bytes,7,opt,name=matching_rule,json=matchingRule,proto3" json:"matching_rule,omitempty"`
	// True if current service_accounts.cfg rules allow this token.
	AllowedByRules       bool     `protobuf:"varint,8,opt,name=allowed_by_rules,json=allowedByRules,proto3" json:"allowed_by_rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectOAuthTokenGrantResponse) Reset()         { *m = InspectOAuthTokenGrantResponse{} }
func (m *InspectOAuthTokenGrantResponse) String() string { return proto.CompactTextString(m) }
func (*InspectOAuthTokenGrantResponse) ProtoMessage()    {}
func (*InspectOAuthTokenGrantResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_303c2e4773396ed5, []int{6}
}

func (m *InspectOAuthTokenGrantResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InspectOAuthTokenGrantResponse.Unmarshal(m, b)
}
func (m *InspectOAuthTokenGrantResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InspectOAuthTokenGrantResponse.Marshal(b, m, deterministic)
}
func (m *InspectOAuthTokenGrantResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectOAuthTokenGrantResponse.Merge(m, src)
}
func (m *InspectOAuthTokenGrantResponse) XXX_Size() int {
	return xxx_messageInfo_InspectOAuthTokenGrantResponse.Size(m)
}
func (m *InspectOAuthTokenGrantResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectOAuthTokenGrantResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InspectOAuthTokenGrantResponse proto.InternalMessageInfo

func (m *InspectOAuthTokenGrantResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *InspectOAuthTokenGrantResponse) GetInvalidityReason() string {
	if m != nil {
		return m.InvalidityReason
	}
	return ""
}

func (m *InspectOAuthTokenGrantResponse) GetSigned() bool {
	if m != nil {
		return m.Signed
	}
	return false
}

func (m *InspectOAuthTokenGrantResponse) GetNonExpired() bool {
	if m != nil {
		return m.NonExpired
	}
	return false
}

func (m *InspectOAuthTokenGrantResponse) GetSigningKeyId() string {
	if m != nil {
		return m.SigningKeyId
	}
	return ""
}

func (m *InspectOAuthTokenGrantResponse) GetTokenBody() *api.OAuthTokenGrantBody {
	if m != nil {
		return m.TokenBody
	}
	return nil
}

func (m *InspectOAuthTokenGrantResponse) GetMatchingRule() *ServiceAccountRule {
	if m != nil {
		return m.MatchingRule
	}
	return nil
}

func (m *InspectOAuthTokenGrantResponse) GetAllowedByRules() bool {
	if m != nil {
		return m.AllowedByRules
	}
	return false
}

func init() {
	proto.RegisterType((*ImportedConfigs)(nil), "tokenserver.admin.ImportedConfigs")
	proto.RegisterType((*InspectMachineTokenRequest)(nil), "tokenserver.admin.InspectMachineTokenRequest")
	proto.RegisterType((*InspectMachineTokenResponse)(nil), "tokenserver.admin.InspectMachineTokenResponse")
	proto.RegisterType((*InspectDelegationTokenRequest)(nil), "tokenserver.admin.InspectDelegationTokenRequest")
	proto.RegisterType((*InspectDelegationTokenResponse)(nil), "tokenserver.admin.InspectDelegationTokenResponse")
	proto.RegisterType((*InspectOAuthTokenGrantRequest)(nil), "tokenserver.admin.InspectOAuthTokenGrantRequest")
	proto.RegisterType((*InspectOAuthTokenGrantResponse)(nil), "tokenserver.admin.InspectOAuthTokenGrantResponse")
}

func init() {
	proto.RegisterFile("github.com/TriggerMail/luci-go/tokenserver/api/admin/v1/admin.proto", fileDescriptor_303c2e4773396ed5)
}

var fileDescriptor_303c2e4773396ed5 = []byte{
	// 743 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x55, 0xdf, 0x6f, 0xd3, 0x30,
	0x10, 0xa6, 0x63, 0xed, 0x3a, 0xb7, 0x8c, 0xcd, 0x4c, 0x23, 0x74, 0x0c, 0xaa, 0x0a, 0xa4, 0x49,
	0x68, 0x09, 0x2b, 0x9a, 0x04, 0x68, 0x12, 0xea, 0xc6, 0x04, 0x03, 0x0d, 0xa4, 0x6c, 0xbc, 0xec,
	0x25, 0x4a, 0x93, 0x5b, 0x6a, 0x2d, 0xb1, 0x43, 0xec, 0x14, 0xf2, 0xc0, 0x13, 0x7f, 0x28, 0x7f,
	0x07, 0x0f, 0x48, 0x28, 0x76, 0xd2, 0x9f, 0x69, 0xb5, 0x49, 0x7b, 0xd8, 0x9b, 0x7d, 0xbe, 0xef,
	0xbb, 0xf3, 0xdd, 0xe7, 0x33, 0x7a, 0xe3, 0x31, 0xdd, 0xe9, 0x45, 0x2c, 0x20, 0x71, 0xa0, 0xb3,
	0xc8, 0x33, 0xfc, 0xd8, 0x21, 0x86, 0x60, 0x97, 0x40, 0x39, 0x44, 0x7d, 0x88, 0x0c, 0x3b, 0x24,
	0x86, 0xed, 0x06, 0x84, 0x1a, 0xfd, 0x5d, 0xb5, 0xd0, 0xc3, 0x88, 0x09, 0x86, 0xd7, 0x46, 0xbc,
	0x74, 0x79, 0xd0, 0xd8, 0xf4, 0x18, 0xf3, 0x7c, 0x30, 0xa4, 0x43, 0x37, 0xbe, 0x30, 0x20, 0x08,
	0x45, 0xa2, 0xfc, 0x1b, 0x47, 0x85, 0xa1, 0xf2, 0x28, 0xb1, 0xe8, 0x19, 0x2e, 0xf8, 0xe0, 0xd9,
	0x82, 0x30, 0x6a, 0x04, 0xc0, 0xb9, 0xed, 0x01, 0x1f, 0xb1, 0x65, 0x34, 0x6f, 0xaf, 0x97, 0xb1,
	0xc3, 0xe8, 0x05, 0xf1, 0x32, 0xec, 0xeb, 0x2b, 0x61, 0x03, 0xdb, 0xe9, 0x11, 0x0a, 0x96, 0xb4,
	0x67, 0xc8, 0xfd, 0x2b, 0x21, 0x59, 0x7a, 0x0d, 0x85, 0xb3, 0xbc, 0xc8, 0xa6, 0x42, 0xa1, 0x5b,
	0x3b, 0xe8, 0xfe, 0x71, 0x10, 0xb2, 0x48, 0x80, 0x7b, 0x28, 0xf3, 0xe1, 0xb8, 0x81, 0xaa, 0x11,
	0xf4, 0x09, 0x27, 0x8c, 0x6a, 0xa5, 0x66, 0x69, 0x7b, 0xd9, 0x1c, 0xec, 0x5b, 0x21, 0x6a, 0x1c,
	0x53, 0x1e, 0x82, 0x23, 0x4e, 0x54, 0x2a, 0x67, 0x29, 0xa3, 0x09, 0xdf, 0x63, 0xe0, 0x02, 0xef,
	0x23, 0xa4, 0x22, 0x88, 0x24, 0x04, 0x89, 0x5d, 0x69, 0x6f, 0xe9, 0xa3, 0xcd, 0x18, 0x45, 0x9d,
	0x25, 0x21, 0x98, 0xcb, 0x22, 0x5f, 0xe2, 0x75, 0x54, 0x96, 0x1b, 0x6d, 0x41, 0x06, 0x55, 0x9b,
	0xd6, 0x9f, 0x05, 0xb4, 0x59, 0x18, 0x92, 0x87, 0x8c, 0x72, 0x89, 0xea, 0xdb, 0x3e, 0x71, 0x65,
	0xb8, 0xaa, 0xa9, 0x36, 0xf8, 0x05, 0x5a, 0x23, 0x54, 0x2e, 0x89, 0x48, 0xac, 0x08, 0x6c, 0xce,
	0x72, 0xde, 0xd5, 0xe1, 0x81, 0x29, 0xed, 0x78, 0x03, 0x55, 0x38, 0xf1, 0x28, 0xb8, 0xda, 0x5d,
	0xc9, 0x91, 0xed, 0xf0, 0x53, 0x54, 0xa3, 0x8c, 0x5a, 0xf0, 0x33, 0x24, 0x11, 0xb8, 0xda, 0xa2,
	0x3c, 0x44, 0x94, 0xd1, 0x23, 0x65, 0xc9, 0x1d, 0x22, 0xe8, 0xb3, 0x4b, 0x70, 0xb5, 0xf2, 0xc0,
	0xc1, 0x54, 0x16, 0xfc, 0x0c, 0xad, 0xa4, 0x5c, 0x84, 0x7a, 0xd6, 0x25, 0x24, 0x16, 0x71, 0xb5,
	0x8a, 0xcc, 0xa1, 0x9e, 0x59, 0x3f, 0x43, 0x72, 0xec, 0xe2, 0x26, 0xaa, 0x3b, 0x10, 0x09, 0xcb,
	0xb1, 0x2d, 0x6a, 0x07, 0xa0, 0x2d, 0x49, 0x1f, 0x94, 0xda, 0x0e, 0xed, 0x2f, 0x76, 0x00, 0xf8,
	0x04, 0xe1, 0xb4, 0xab, 0xd6, 0x58, 0xff, 0xb5, 0xf5, 0x66, 0x69, 0xbb, 0x36, 0xa7, 0xc0, 0x07,
	0xcc, 0x4d, 0x3e, 0xde, 0x31, 0x57, 0x53, 0xe8, 0x98, 0xbd, 0x3e, 0xda, 0xa7, 0xd6, 0x1e, 0xda,
	0xca, 0x0a, 0xfc, 0x7e, 0xa0, 0xe8, 0xb1, 0xb6, 0x0e, 0x1a, 0x53, 0x1a, 0x6d, 0xcc, 0xef, 0x05,
	0xf4, 0x64, 0x16, 0xee, 0x16, 0xf4, 0x66, 0x0f, 0x55, 0x81, 0xf6, 0xc1, 0x67, 0x21, 0xc8, 0xc6,
	0xd4, 0xda, 0x8f, 0xf4, 0xfc, 0xe9, 0xea, 0x93, 0x09, 0x0f, 0x5c, 0xb1, 0x8e, 0xaa, 0x3c, 0xee,
	0xaa, 0xeb, 0x56, 0x24, 0x0c, 0x0f, 0x61, 0xa7, 0xd9, 0x89, 0x39, 0xf0, 0x19, 0x29, 0xde, 0xd7,
	0x4e, 0x2c, 0x7a, 0x92, 0xee, 0x43, 0xfa, 0xbe, 0xe6, 0x17, 0xef, 0xef, 0xb0, 0x78, 0x53, 0xb8,
	0x5b, 0x50, 0xbc, 0x69, 0xdd, 0x96, 0x0b, 0x74, 0xfb, 0x2e, 0x97, 0x51, 0x97, 0xb9, 0x49, 0x56,
	0xad, 0xe6, 0x98, 0x1a, 0x27, 0xee, 0x96, 0x0a, 0x32, 0x7b, 0xf1, 0xe9, 0x12, 0x7f, 0x42, 0xf7,
	0x02, 0x5b, 0xa4, 0xc2, 0xf4, 0xac, 0x28, 0xf6, 0x95, 0xf2, 0x6b, 0xed, 0xe7, 0xfa, 0xd4, 0xfc,
	0xd6, 0x4f, 0x21, 0xea, 0x13, 0x07, 0x3a, 0x8e, 0xc3, 0x62, 0x2a, 0xcc, 0xd8, 0x07, 0xb3, 0x9e,
	0x63, 0xd3, 0x1d, 0xde, 0x46, 0xab, 0xb6, 0xef, 0xb3, 0x1f, 0xe0, 0x5a, 0xdd, 0x44, 0xb2, 0x71,
	0xad, 0x2a, 0x2f, 0xb6, 0x92, 0xd9, 0x0f, 0x92, 0xd4, 0x91, 0xb7, 0xff, 0x2d, 0xa2, 0x72, 0x27,
	0x25, 0xc5, 0x27, 0xf9, 0xf0, 0x3b, 0xec, 0xe4, 0xc3, 0x6f, 0x43, 0x57, 0x1f, 0x85, 0x9e, 0x7f,
	0x14, 0xfa, 0x51, 0xfa, 0x51, 0x34, 0x5a, 0x05, 0x39, 0x4d, 0x0e, 0xce, 0x6f, 0xe8, 0xa1, 0x32,
	0x0d, 0xe5, 0x75, 0x13, 0xb4, 0xe7, 0xe8, 0xb1, 0x32, 0x8d, 0xd7, 0x80, 0xdf, 0x04, 0xb7, 0x40,
	0x0f, 0x0a, 0x86, 0x2b, 0xde, 0x29, 0x82, 0xce, 0x9c, 0xfb, 0x0d, 0xfd, 0xaa, 0xee, 0x99, 0xb4,
	0x7f, 0xa1, 0x8d, 0xe2, 0xc9, 0x81, 0x5f, 0xce, 0x66, 0x2a, 0x1e, 0x4e, 0x8d, 0xdd, 0x6b, 0x20,
	0xa6, 0xc2, 0x4f, 0xe8, 0x73, 0x5e, 0xf8, 0xe2, 0xe7, 0x3d, 0x2f, 0xfc, 0x8c, 0x87, 0x7d, 0xb0,
	0x74, 0x5e, 0x96, 0x7e, 0xdd, 0x8a, 0x6c, 0xd8, 0xab, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd6,
	0xeb, 0x8d, 0xdc, 0xea, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AdminClient is the client API for Admin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AdminClient interface {
	// ImportCAConfigs makes the server read 'tokenserver.cfg'.
	ImportCAConfigs(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ImportedConfigs, error)
	// ImportDelegationConfigs makes the server read 'delegation.cfg'.
	ImportDelegationConfigs(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ImportedConfigs, error)
	// ImportServiceAccountsConfigs makes the server read 'service_accounts.cfg'.
	ImportServiceAccountsConfigs(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ImportedConfigs, error)
	// InspectMachineToken decodes a machine token and verifies it is valid.
	//
	// It verifies the token was signed by a private key of the token server and
	// checks token's expiration time and revocation status.
	//
	// It tries to give as much information about the token and its status as
	// possible (e.g. it checks for revocation status even if token is already
	// expired).
	//
	// Administrators can use this call to debug issues with tokens.
	//
	// Returns:
	//   InspectMachineTokenResponse for tokens of supported kind.
	//   grpc.InvalidArgument error for unsupported token kind.
	//   grpc.Internal error for transient errors.
	InspectMachineToken(ctx context.Context, in *InspectMachineTokenRequest, opts ...grpc.CallOption) (*InspectMachineTokenResponse, error)
	// InspectDelegationToken decodes a delegation token and verifies it is valid.
	//
	// It verifies the token was signed by a private key of the token server and
	// checks token's expiration time.
	//
	// It tries to give as much information about the token and its status as
	// possible (e.g. attempts to decode the body even if the signing key has been
	// rotated already).
	//
	// Administrators can use this call to debug issues with tokens.
	//
	// Returns:
	//   InspectDelegationTokenResponse for tokens of supported kind.
	//   grpc.InvalidArgument error for unsupported token kind.
	//   grpc.Internal error for transient errors.
	InspectDelegationToken(ctx context.Context, in *InspectDelegationTokenRequest, opts ...grpc.CallOption) (*InspectDelegationTokenResponse, error)
	// InspectOAuthTokenGrant decodes OAuth token grant and verifies it is valid.
	//
	// It verifies the token was signed by a private key of the token server and
	// checks token's expiration time.
	//
	// It tries to give as much information about the token and its status as
	// possible (e.g. attempts to decode the body even if the signing key has been
	// rotated already).
	//
	// Administrators can use this call to debug issues with tokens.
	//
	// Returns:
	//   InspectOAuthTokenGrantResponse for tokens of supported kind.
	//   grpc.InvalidArgument error for unsupported token kind.
	//   grpc.Internal error for transient errors.
	InspectOAuthTokenGrant(ctx context.Context, in *InspectOAuthTokenGrantRequest, opts ...grpc.CallOption) (*InspectOAuthTokenGrantResponse, error)
}
type adminPRPCClient struct {
	client *prpc.Client
}

func NewAdminPRPCClient(client *prpc.Client) AdminClient {
	return &adminPRPCClient{client}
}

func (c *adminPRPCClient) ImportCAConfigs(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ImportedConfigs, error) {
	out := new(ImportedConfigs)
	err := c.client.Call(ctx, "tokenserver.admin.Admin", "ImportCAConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminPRPCClient) ImportDelegationConfigs(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ImportedConfigs, error) {
	out := new(ImportedConfigs)
	err := c.client.Call(ctx, "tokenserver.admin.Admin", "ImportDelegationConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminPRPCClient) ImportServiceAccountsConfigs(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ImportedConfigs, error) {
	out := new(ImportedConfigs)
	err := c.client.Call(ctx, "tokenserver.admin.Admin", "ImportServiceAccountsConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminPRPCClient) InspectMachineToken(ctx context.Context, in *InspectMachineTokenRequest, opts ...grpc.CallOption) (*InspectMachineTokenResponse, error) {
	out := new(InspectMachineTokenResponse)
	err := c.client.Call(ctx, "tokenserver.admin.Admin", "InspectMachineToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminPRPCClient) InspectDelegationToken(ctx context.Context, in *InspectDelegationTokenRequest, opts ...grpc.CallOption) (*InspectDelegationTokenResponse, error) {
	out := new(InspectDelegationTokenResponse)
	err := c.client.Call(ctx, "tokenserver.admin.Admin", "InspectDelegationToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminPRPCClient) InspectOAuthTokenGrant(ctx context.Context, in *InspectOAuthTokenGrantRequest, opts ...grpc.CallOption) (*InspectOAuthTokenGrantResponse, error) {
	out := new(InspectOAuthTokenGrantResponse)
	err := c.client.Call(ctx, "tokenserver.admin.Admin", "InspectOAuthTokenGrant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type adminClient struct {
	cc *grpc.ClientConn
}

func NewAdminClient(cc *grpc.ClientConn) AdminClient {
	return &adminClient{cc}
}

func (c *adminClient) ImportCAConfigs(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ImportedConfigs, error) {
	out := new(ImportedConfigs)
	err := c.cc.Invoke(ctx, "/tokenserver.admin.Admin/ImportCAConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) ImportDelegationConfigs(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ImportedConfigs, error) {
	out := new(ImportedConfigs)
	err := c.cc.Invoke(ctx, "/tokenserver.admin.Admin/ImportDelegationConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) ImportServiceAccountsConfigs(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ImportedConfigs, error) {
	out := new(ImportedConfigs)
	err := c.cc.Invoke(ctx, "/tokenserver.admin.Admin/ImportServiceAccountsConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) InspectMachineToken(ctx context.Context, in *InspectMachineTokenRequest, opts ...grpc.CallOption) (*InspectMachineTokenResponse, error) {
	out := new(InspectMachineTokenResponse)
	err := c.cc.Invoke(ctx, "/tokenserver.admin.Admin/InspectMachineToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) InspectDelegationToken(ctx context.Context, in *InspectDelegationTokenRequest, opts ...grpc.CallOption) (*InspectDelegationTokenResponse, error) {
	out := new(InspectDelegationTokenResponse)
	err := c.cc.Invoke(ctx, "/tokenserver.admin.Admin/InspectDelegationToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) InspectOAuthTokenGrant(ctx context.Context, in *InspectOAuthTokenGrantRequest, opts ...grpc.CallOption) (*InspectOAuthTokenGrantResponse, error) {
	out := new(InspectOAuthTokenGrantResponse)
	err := c.cc.Invoke(ctx, "/tokenserver.admin.Admin/InspectOAuthTokenGrant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServer is the server API for Admin service.
type AdminServer interface {
	// ImportCAConfigs makes the server read 'tokenserver.cfg'.
	ImportCAConfigs(context.Context, *empty.Empty) (*ImportedConfigs, error)
	// ImportDelegationConfigs makes the server read 'delegation.cfg'.
	ImportDelegationConfigs(context.Context, *empty.Empty) (*ImportedConfigs, error)
	// ImportServiceAccountsConfigs makes the server read 'service_accounts.cfg'.
	ImportServiceAccountsConfigs(context.Context, *empty.Empty) (*ImportedConfigs, error)
	// InspectMachineToken decodes a machine token and verifies it is valid.
	//
	// It verifies the token was signed by a private key of the token server and
	// checks token's expiration time and revocation status.
	//
	// It tries to give as much information about the token and its status as
	// possible (e.g. it checks for revocation status even if token is already
	// expired).
	//
	// Administrators can use this call to debug issues with tokens.
	//
	// Returns:
	//   InspectMachineTokenResponse for tokens of supported kind.
	//   grpc.InvalidArgument error for unsupported token kind.
	//   grpc.Internal error for transient errors.
	InspectMachineToken(context.Context, *InspectMachineTokenRequest) (*InspectMachineTokenResponse, error)
	// InspectDelegationToken decodes a delegation token and verifies it is valid.
	//
	// It verifies the token was signed by a private key of the token server and
	// checks token's expiration time.
	//
	// It tries to give as much information about the token and its status as
	// possible (e.g. attempts to decode the body even if the signing key has been
	// rotated already).
	//
	// Administrators can use this call to debug issues with tokens.
	//
	// Returns:
	//   InspectDelegationTokenResponse for tokens of supported kind.
	//   grpc.InvalidArgument error for unsupported token kind.
	//   grpc.Internal error for transient errors.
	InspectDelegationToken(context.Context, *InspectDelegationTokenRequest) (*InspectDelegationTokenResponse, error)
	// InspectOAuthTokenGrant decodes OAuth token grant and verifies it is valid.
	//
	// It verifies the token was signed by a private key of the token server and
	// checks token's expiration time.
	//
	// It tries to give as much information about the token and its status as
	// possible (e.g. attempts to decode the body even if the signing key has been
	// rotated already).
	//
	// Administrators can use this call to debug issues with tokens.
	//
	// Returns:
	//   InspectOAuthTokenGrantResponse for tokens of supported kind.
	//   grpc.InvalidArgument error for unsupported token kind.
	//   grpc.Internal error for transient errors.
	InspectOAuthTokenGrant(context.Context, *InspectOAuthTokenGrantRequest) (*InspectOAuthTokenGrantResponse, error)
}

func RegisterAdminServer(s prpc.Registrar, srv AdminServer) {
	s.RegisterService(&_Admin_serviceDesc, srv)
}

func _Admin_ImportCAConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ImportCAConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenserver.admin.Admin/ImportCAConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ImportCAConfigs(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ImportDelegationConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ImportDelegationConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenserver.admin.Admin/ImportDelegationConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ImportDelegationConfigs(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ImportServiceAccountsConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ImportServiceAccountsConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenserver.admin.Admin/ImportServiceAccountsConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ImportServiceAccountsConfigs(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_InspectMachineToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectMachineTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).InspectMachineToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenserver.admin.Admin/InspectMachineToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).InspectMachineToken(ctx, req.(*InspectMachineTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_InspectDelegationToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectDelegationTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).InspectDelegationToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenserver.admin.Admin/InspectDelegationToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).InspectDelegationToken(ctx, req.(*InspectDelegationTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_InspectOAuthTokenGrant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectOAuthTokenGrantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).InspectOAuthTokenGrant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenserver.admin.Admin/InspectOAuthTokenGrant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).InspectOAuthTokenGrant(ctx, req.(*InspectOAuthTokenGrantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Admin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tokenserver.admin.Admin",
	HandlerType: (*AdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportCAConfigs",
			Handler:    _Admin_ImportCAConfigs_Handler,
		},
		{
			MethodName: "ImportDelegationConfigs",
			Handler:    _Admin_ImportDelegationConfigs_Handler,
		},
		{
			MethodName: "ImportServiceAccountsConfigs",
			Handler:    _Admin_ImportServiceAccountsConfigs_Handler,
		},
		{
			MethodName: "InspectMachineToken",
			Handler:    _Admin_InspectMachineToken_Handler,
		},
		{
			MethodName: "InspectDelegationToken",
			Handler:    _Admin_InspectDelegationToken_Handler,
		},
		{
			MethodName: "InspectOAuthTokenGrant",
			Handler:    _Admin_InspectOAuthTokenGrant_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/TriggerMail/luci-go/tokenserver/api/admin/v1/admin.proto",
}
